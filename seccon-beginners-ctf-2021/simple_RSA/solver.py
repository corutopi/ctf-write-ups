"""
解法:
    公開鍵nを素因数分解することは(時間内では)できない。
    暗号化されているflagのbit数と公開乗数eに着目すると、
        (2 ** 375) ** 3 = 2 ** 1125
        1125 < 2046（公開鍵のbit桁数）
    となり、暗号化後の c の値は単純に暗号化前の flag をe乗した値のままであることがわかる。
    よって c のe乗根がflagとなる。
    c も巨大数なため素因数分解はできないが、x ** 3 = c となる値xを 0 ～ 2**376 の間で2分探索すれば高速に求められる。
flag:
    ctf4b{0,1,10,11...It's_so_annoying.___I'm_done}
その他:
    本solver の実行には Crypto モジュールのインストールが必要。
    windows の場合
        $ pip install pycryptodome
    linux の場合
        $ pip install pycrypto
"""

from Crypto.Util.number import *

c = 213791751530017111508691084168363024686878057337971319880256924185393737150704342725042841488547315925971960389230453332319371876092968032513149023976287158698990251640298360876589330810813199260879441426084508864252450551111064068694725939412142626401778628362399359107132506177231354040057205570428678822068599327926328920350319336256613


def binary_search(ok, ng, solve):
    """めぐる式2分探索"""
    while abs(ok - ng) > 1:
        mid = (ok + ng) // 2
        if solve(mid):
            ok = mid
        else:
            ng = mid
    return ok


print(long_to_bytes(binary_search(2 ** 376, 0, lambda x: x ** 3 >= c)))
